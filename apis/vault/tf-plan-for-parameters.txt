Terraform will perform the following actions:

  # vault_auth_backend.userpass will be created
  + resource "vault_auth_backend" "userpass" {
      + accessor        = (known after apply)
      + disable_remount = false
      + id              = (known after apply)
      + path            = (known after apply)
      + tune            = (known after apply)
      + type            = "userpass"
    }

  # vault_generic_endpoint.student will be created
  + resource "vault_generic_endpoint" "student" {
      + data_json            = (sensitive value)
      + disable_delete       = false
      + disable_read         = false
      + id                   = (known after apply)
      + ignore_absent_fields = true
      + path                 = "auth/userpass/users/student"
      + write_data           = (known after apply)
      + write_data_json      = (known after apply)
    }

  # vault_mount.kv-v2 will be created
  + resource "vault_mount" "kv-v2" {
      + accessor                     = (known after apply)
      + audit_non_hmac_request_keys  = (known after apply)
      + audit_non_hmac_response_keys = (known after apply)
      + default_lease_ttl_seconds    = (known after apply)
      + external_entropy_access      = false
      + id                           = (known after apply)
      + max_lease_ttl_seconds        = (known after apply)
      + path                         = "kv-v2"
      + seal_wrap                    = (known after apply)
      + type                         = "kv-v2"
    }

  # vault_mount.transit will be created
  + resource "vault_mount" "transit" {
      + accessor                     = (known after apply)
      + audit_non_hmac_request_keys  = (known after apply)
      + audit_non_hmac_response_keys = (known after apply)
      + default_lease_ttl_seconds    = (known after apply)
      + external_entropy_access      = false
      + id                           = (known after apply)
      + max_lease_ttl_seconds        = (known after apply)
      + path                         = "transit"
      + seal_wrap                    = (known after apply)
      + type                         = "transit"
    }

  # vault_policy.admin_policy will be created
  + resource "vault_policy" "admin_policy" {
      + id     = (known after apply)
      + name   = "admins"
      + policy = <<-EOT
            # Manage auth methods broadly across Vault
            path "auth/*"
            {
              capabilities = ["create", "read", "update", "delete", "list", "sudo"]
            }

            # Create, update, and delete auth methods
            path "sys/auth/*"
            {
              capabilities = ["create", "update", "delete", "sudo"]
            }

            # List auth methods
            path "sys/auth"
            {
              capabilities = ["read"]
            }

            # Create and manage ACL policies
            path "sys/policies/acl/*"
            {
              capabilities = ["create", "read", "update", "delete", "list", "sudo"]
            }

            # List ACL policies
            path "sys/policies/acl"
            {
              capabilities = ["list"]
            }

            # Create and manage secrets engines broadly across Vault.
            path "sys/mounts/*"
            {
              capabilities = ["create", "read", "update", "delete", "list", "sudo"]
            }

            # List enabled secrets engines
            path "sys/mounts"
            {
              capabilities = ["read", "list"]
            }

            # List, create, update, and delete key/value secrets at secret/
            path "secret/*"
            {
              capabilities = ["create", "read", "update", "delete", "list", "sudo"]
            }

            # Manage transit secrets engine
            path "transit/*"
            {
              capabilities = ["create", "read", "update", "delete", "list", "sudo"]
            }

            # Read health checks
            path "sys/health"
            {
              capabilities = ["read", "sudo"]
            }
        EOT
    }

  # vault_policy.eaas-client will be created
  + resource "vault_policy" "eaas-client" {
      + id     = (known after apply)
      + name   = "eaas-client"
      + policy = <<-EOT
            # Permits CRUD operation on kv-v2
            path "kv-v2/data/*" {
              capabilities = ["create", "read", "update", "delete", "list"]
            }

            # Encrypt data with 'payment' key
            path "transit/encrypt/payment" {
              capabilities = ["update"]
            }

            # Decrypt data with 'payment' key
            path "transit/decrypt/payment" {
              capabilities = ["update"]
            }

            # Read and list keys under transit secrets engine
            path "transit/*" {
              capabilities = ["read", "list"]
            }

            # List enabled secrets engines
            path "secret/metadata/*" {
               capabilities = ["list"]
            }
        EOT
    }

  # vault_transit_secret_backend_key.key will be created
  + resource "vault_transit_secret_backend_key" "key" {
      + allow_plaintext_backup = false
      + auto_rotate_interval   = (known after apply)
      + auto_rotate_period     = (known after apply)
      + backend                = "transit"
      + convergent_encryption  = false
      + deletion_allowed       = true
      + derived                = false
      + exportable             = false
      + id                     = (known after apply)
      + key_size               = 0
      + keys                   = (known after apply)
      + latest_version         = (known after apply)
      + min_available_version  = (known after apply)
      + min_decryption_version = 1
      + min_encryption_version = 0
      + name                   = "payment"
      + supports_decryption    = (known after apply)
      + supports_derivation    = (known after apply)
      + supports_encryption    = (known after apply)
      + supports_signing       = (known after apply)
      + type                   = "aes256-gcm96"
    }

